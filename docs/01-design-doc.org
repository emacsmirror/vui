#+TITLE: vui.el: Design Document
#+AUTHOR: Boris
#+DATE: November 2025
#+UPDATED: December 2025
#+VERSION: 1.0 (Feature Complete)

#+begin_warning
*Note*: This is a design document that was written during development. While it has been updated to reflect the current implementation, some details may drift over time. For authoritative usage guidance, refer to the tutorial articles in =docs/guide/=. When in doubt, the source code in =vui.el= is the definitive reference.
#+end_warning

*vui.el* (Virtual UI) is a declarative, component-based UI library for Emacs. It brings React-like patterns to buffer-based interfaces: define components as functions of state, compose them into trees, and let the library handle efficient updates through reconciliation. Built on top of =widget.el= for battle-tested input handling, vui.el adds state management, automatic re-rendering, cursor preservation, and layout primitives for building complex, interactive UIs in Emacs buffers.

* Introduction

** Motivation

Emacs's built-in =widget.el= library provides a foundation for creating interactive UI elements in buffers. However, it has limitations when building complex, dynamic interfaces:

- *Imperative updates*: Widgets are created and modified imperatively, making it hard to reason about UI state.
- *No diffing*: Changes require manual deletion and recreation of widgets.
- *Coupled state*: Widget state is mixed with rendering logic.
- *Limited composition*: Composing widgets into complex layouts is cumbersome.

vui.el aims to bring React's declarative, component-based model to Emacs, enabling developers to build complex UIs by describing /what/ should be rendered, not /how/ to update it.

** Core Philosophy

1. *Declarative*: Describe the UI as a function of state, not as a sequence of mutations.
2. *Component-based*: Build complex UIs from small, reusable, composable pieces.
3. *Unidirectional data flow*: Data flows down through props; events flow up through callbacks.
4. *Predictable*: Same props + state always produces the same output.
5. *Emacs-native*: Respect Emacs conventions (point, markers, keymaps, faces).

** Key Differences from React

| Aspect           | React                     | vui.el                              |
|------------------+---------------------------+-------------------------------------|
| Render target    | DOM (tree of nodes)       | Buffer (linear text with overlays)  |
| User interaction | Mouse/keyboard events     | Point position + keyboard           |
| Focus model      | Explicit focus management | Point is always "focused"           |
| Layout           | CSS (flexbox, grid)       | Character-based (columns, rows)     |
| Async            | Concurrent rendering      | Single-threaded, idle-time batching |


* Goals and Non-Goals

** Goals

- *Declarative component model* with props, state, and render functions
- *Efficient reconciliation* that minimises buffer mutations
- *Cursor preservation* across re-renders (critical for Emacs UX)
- *Composition primitives* for horizontal, vertical, and tabular layouts
- *Reactive state management* with =vui-set-state=
- *Context system* for deep data passing without prop drilling
- *Lifecycle hooks* for mount, unmount, and update events
- *Batched updates* to avoid redundant re-renders
- *Error boundaries* for graceful failure handling
- *Interoperability* with existing Emacs facilities (keymaps, faces, hooks)

** Non-Goals

- *Full CSS-like layout*: We work within buffer constraints (monospace, linear text)
- *Animation*: No built-in animation system (though hooks could enable it)
- *Server-side rendering*: Not applicable to Emacs
- *Concurrent rendering*: Emacs is single-threaded; we use idle timers instead
- *Backward compatibility with widget.el*: Clean break, though we wrap widgets internally

* Foundational Architecture

** High-Level Overview

#+begin_example
+-----------------------------------------------------------------+
|                        User Code                                |
|  (defcomponent todo-item (text done) ...)                       |
+-----------------------------------------------------------------+
                              |
                              v
+-----------------------------------------------------------------+
|                    Component Registry                           |
|  Stores component definitions (type -> definition)              |
+-----------------------------------------------------------------+
                              |
                              v
+-----------------------------------------------------------------+
|                    Component Tree (Virtual)                     |
|  In-memory tree of component instances with props/state         |
|  This is the "Virtual DOM" equivalent                           |
+-----------------------------------------------------------------+
                              |
                              v
+-----------------------------------------------------------------+
|                    Reconciler                                   |
|  Compares old tree vs new tree                                  |
|  Determines which components need re-rendering                  |
+-----------------------------------------------------------------+
                              |
                              v
+-----------------------------------------------------------------+
|                    Buffer Renderer                              |
|  Clears and re-renders buffer content                           |
|  Handles cursor preservation via widget indexing                |
+-----------------------------------------------------------------+
                              |
                              v
+-----------------------------------------------------------------+
|                    Emacs Buffer                                 |
|  The actual visible text with widgets and text properties       |
+-----------------------------------------------------------------+
#+end_example

** The Render Cycle

#+begin_example
State Change (vui-set-state)
     |
     v
+--------------+
| Schedule     |  Batch multiple changes, defer via timer
+--------------+
     |
     v
+--------------+
| Save cursor  |  Track cursor position relative to widgets
+--------------+
     |
     v
+--------------+
| Clear buffer |  Remove widget overlays, erase content
+--------------+
     |
     v
+--------------+
| Render phase |  Build new virtual tree, render to buffer
+--------------+
     |
     v
+--------------+
| Widget setup |  Call widget-setup for keyboard navigation
+--------------+
     |
     v
+--------------+
| Restore      |  Restore cursor to same widget index
+--------------+
     |
     v
+--------------+
| Run effects  |  Execute pending use-effect callbacks
+--------------+
#+end_example

** Key Design Decisions

*Decision 1: Immutable props, mutable state*
- Props flow down from parent, are read-only to child
- State is owned by component, changes trigger re-render via =vui-set-state=

*Decision 2: Render functions are pure*
- Given same props and state, produce same virtual tree
- No direct buffer manipulation in render

*Decision 3: Virtual tree is a simple data structure*
- Easy to diff, serialise, inspect
- No circular references in the tree itself (parent refs stored separately)

*Decision 4: Buffer is the "DOM"*
- Text content + widgets + text properties
- All buffer mutations go through the renderer, never direct

*Decision 5: Build on widget.el for input primitives*
- =vui-field= wraps =editable-field= widget
- =vui-button= wraps =push-button= widget
- =vui-checkbox= wraps =checkbox= widget
- =vui-select= uses =push-button= with =completing-read=
- TAB navigation, field editing come free from widget library
- We provide: component model, state management, layout, reconciliation
- Widget.el provides: battle-tested input handling, keyboard navigation

*Decision 6: Clear-and-rerender approach*
- On state change, clear buffer and re-render entire tree
- Simpler than fine-grained DOM diffing
- Widget preservation via =widget-setup= after render
- Cursor preserved by tracking widget index before/after

* Core Data Structures

** Component Definition

A component definition is a template â€” it describes /how/ to create instances.

#+begin_src elisp
(cl-defstruct (vui-component-def (:constructor vui-component-def--create))
  "Definition of a component type."
  name                    ; Symbol identifying this component type
  props-spec              ; List of prop names (symbols)
  initial-state-fn        ; (lambda (props) state) â€” returns initial state plist
  render-fn               ; (lambda (props state) vtree) â€” pure function

  ;; Lifecycle hooks (all optional)
  on-mount                ; (lambda (props state)) â€” after first render
  on-update               ; (lambda (props state prev-props prev-state))
  on-unmount              ; (lambda (props state)) â€” before removal

  ;; Optimisation
  should-update)          ; (lambda (props state prev-props prev-state) bool)
#+end_src

** Component Instance

An instance is a live component in the tree with actual props, state, and children.

#+begin_src elisp
(cl-defstruct (vui-instance (:constructor vui-instance--create))
  "A live instance of a component."
  id                      ; Unique identifier (for debugging/tracking)
  def                     ; Reference to vui-component-def

  ;; Data
  props                   ; Plist of current props
  state                   ; Current state plist (mutable via vui-set-state)

  ;; Tree structure
  vnode                   ; The vui-vnode-component that created this
  parent                  ; Parent vui-instance (nil for root)
  children                ; List of child vui-instances

  ;; Buffer binding
  buffer                  ; Buffer this instance is rendered into

  ;; Lifecycle state
  mounted-p               ; Has on-mount been called?
  mount-cleanup           ; Cleanup function returned from on-mount

  ;; Hook state
  effects                 ; Alist: (effect-id . (deps . cleanup-fn))
  refs                    ; Hash table: ref-id -> (value . nil)
  callbacks               ; Hash table: callback-id -> (deps . fn)
  memos                   ; Hash table: memo-id -> (deps . value)
  asyncs                  ; Hash table: async-id -> state plist

  ;; For lifecycle hooks
  prev-props              ; Props from previous render
  prev-state              ; State from previous render

  ;; Cache
  cached-vtree)           ; Last rendered virtual tree
#+end_src

** Virtual Tree Nodes

The virtual tree is what render functions produce. It's a pure data structure.

#+begin_src elisp
;; Base structure for all virtual nodes
(cl-defstruct (vui-vnode (:constructor nil))
  "Base type for virtual tree nodes."
  key)                    ; Optional key for reconciliation

;; A reference to a component (will be instantiated)
(cl-defstruct (vui-vnode-component (:include vui-vnode)
                                   (:constructor vui-vnode-component--create))
  "Virtual node representing a component."
  type                    ; Symbol â€” the component type name
  props                   ; Plist of props to pass
  children)               ; List of child vnodes (passed as :children prop)

;; Primitive: raw text
(cl-defstruct (vui-vnode-text (:include vui-vnode)
                              (:constructor vui-vnode-text--create))
  "Virtual node representing plain text."
  content                 ; String
  face                    ; Face or nil
  properties)             ; Additional text properties plist

;; Primitive: editable field
(cl-defstruct (vui-vnode-field (:include vui-vnode)
                               (:constructor vui-vnode-field--create))
  "Virtual node representing an editable text field."
  value                   ; Current string value
  size                    ; Width in characters (nil = default 20)
  placeholder             ; Hint text (not yet rendered)
  on-change               ; (lambda (new-value)) â€” triggers re-render
  on-submit               ; (lambda (value)) â€” called on RET, no re-render
  face
  secret-p)               ; Hide input for passwords

;; Primitive: clickable button
(cl-defstruct (vui-vnode-button (:include vui-vnode)
                                (:constructor vui-vnode-button--create))
  "Virtual node representing a button."
  label                   ; String
  on-click                ; (lambda ())
  face
  disabled-p
  max-width)              ; Truncate label if exceeded

;; Primitive: checkbox
(cl-defstruct (vui-vnode-checkbox (:include vui-vnode)
                                  (:constructor vui-vnode-checkbox--create))
  "Boolean checkbox."
  checked-p
  on-change               ; (lambda (new-bool-value))
  label)                  ; Optional label after checkbox

;; Primitive: select (dropdown via completing-read)
(cl-defstruct (vui-vnode-select (:include vui-vnode)
                                (:constructor vui-vnode-select--create))
  "Selection from options."
  value                   ; Current selection
  options                 ; List of choices
  on-change               ; (lambda (new-value))
  prompt)                 ; Minibuffer prompt

;; Primitive: newline
(cl-defstruct (vui-vnode-newline (:include vui-vnode)
                                 (:constructor vui-vnode-newline--create))
  "Virtual node representing a line break.")

;; Primitive: horizontal space
(cl-defstruct (vui-vnode-space (:include vui-vnode)
                               (:constructor vui-vnode-space--create))
  "Virtual node representing whitespace."
  width)                  ; Number of spaces

;; Container: sequence of children (renders children in order)
(cl-defstruct (vui-vnode-fragment (:include vui-vnode)
                                  (:constructor vui-vnode-fragment--create))
  "Virtual node that groups children without wrapper."
  children)               ; List of child vnodes
#+end_src

** Context

For passing data deeply without prop drilling.

#+begin_src elisp
(cl-defstruct (vui-context (:constructor vui-context--create))
  "A context definition."
  name                    ; Symbol identifying this context
  default-value)          ; Value when no provider found

(cl-defstruct (vui-vnode-provider (:include vui-vnode)
                                  (:constructor vui-vnode-provider--create))
  "A context provider vnode."
  context                 ; The vui-context being provided
  value                   ; The value to provide
  children)               ; Child vnodes

(cl-defstruct (vui-context-binding (:constructor vui-context-binding--create))
  "Runtime binding of a context to a value."
  context                 ; The vui-context
  value)                  ; Current provided value
#+end_src

** Error Boundary

#+begin_src elisp
(cl-defstruct (vui-vnode-error-boundary (:include vui-vnode)
                                        (:constructor vui-vnode-error-boundary--create))
  "Virtual node that catches errors from children."
  children                ; Child vnodes to render
  fallback                ; (lambda (error) vnode) to render on error
  on-error                ; Optional (lambda (error)) callback
  id)                     ; Unique identifier for state tracking
#+end_src


* Component Definition DSL

** The =defcomponent= Macro

#+begin_src elisp
(defcomponent todo-item (text done on-toggle on-delete)
  "A single todo item with checkbox and text."

  ;; Initial state (optional)
  :state ((editing nil)
          (edit-text ""))

  ;; Lifecycle hooks (optional)
  :on-mount (message "Todo mounted: %s" text)

  :on-update (when (not (equal (plist-get prev-props :text) text))
               (message "Text changed!"))

  :on-unmount (message "Todo unmounted")

  ;; Optimisation (optional)
  :should-update (or (not (equal text (plist-get prev-props :text)))
                     (not (equal done (plist-get prev-props :done)))
                     (not (equal editing (plist-get prev-state :editing))))

  ;; Render function â€” the body (required)
  :render
  (if editing
      ;; Editing mode
      (vui-hstack
       (vui-field :value edit-text
                  :on-change (lambda (v) (vui-set-state :edit-text v)))
       (vui-button "Save"
         :on-click (lambda ()
                     (vui-set-state :editing nil)
                     (funcall on-toggle)))
       (vui-button "Cancel"
         :on-click (lambda ()
                     (vui-set-state :editing nil)
                     (vui-set-state :edit-text text))))

    ;; Display mode
    (vui-hstack
     (vui-button (if done "[x]" "[ ]")
       :on-click on-toggle)
     (vui-text text :face (when done 'shadow))
     (when on-delete
       (vui-button "Ã—" :on-click on-delete)))))
#+end_src

** Macro Structure

The =defcomponent= macro accepts:

1. *Name*: Symbol identifying the component
2. *Props list*: List of prop names (symbols) the component accepts
3. *Body*: Keyword sections in any order

| Keyword          | Value                                | Required |
|------------------+--------------------------------------+----------|
| =:state=         | List of =(name initial-value)= pairs | No       |
| =:on-mount=      | Form to run after first render       | No       |
| =:on-update=     | Form to run after re-render          | No       |
| =:on-unmount=    | Form to run before removal           | No       |
| =:should-update= | Form returning bool (skip if nil)    | No       |
| =:render=        | Form producing a vnode               | Yes      |

Within all forms, you have access to:
- All props as variables (e.g., =text=, =done=)
- All state variables (e.g., =editing=, =edit-text=)
- =children= â€” child vnodes passed via =:children= prop
- =prev-props= and =prev-state= â€” in =:on-update= and =:should-update=

** State Mutation

State is mutated via =vui-set-state=:

#+begin_src elisp
;; Simple update
(vui-set-state :count (1+ count))

;; Functional update (avoids stale closures in async)
(vui-set-state :count #'1+)

;; Multiple updates (consider vui-batch for efficiency)
(vui-batch
  (vui-set-state :name "Bob")
  (vui-set-state :count 0))
#+end_src

** Primitive Constructors

#+begin_src elisp
(defun vui-text (content &rest props)
  "Create a text vnode.

CONTENT is the string to display.
PROPS: :face, :key, and additional text properties."
  ...)

(defun vui-button (label &rest props)
  "Create a button vnode.

LABEL is the button text (positional first argument).
PROPS: :on-click, :face, :disabled, :max-width, :key."
  ...)

(cl-defun vui-field (&key value size placeholder on-change on-submit
                          face secret key)
  "Create an editable field vnode.

All arguments are keyword-based."
  ...)

(defun vui-checkbox (&rest props)
  "Create a checkbox vnode.

PROPS: :checked, :on-change, :label, :key."
  ...)

(defun vui-select (&rest props)
  "Create a select vnode (uses completing-read).

PROPS: :value, :options, :on-change, :prompt, :key."
  ...)

(defun vui-fragment (&rest children)
  "Group multiple vnodes without adding wrapper text.

Filters out nil children for conditional rendering."
  ...)

(defun vui-newline (&optional key)
  "Create a line break vnode."
  ...)

(defun vui-space (&optional width key)
  "Create horizontal whitespace. WIDTH defaults to 1."
  ...)
#+end_src

* Layout System

** Buffer Constraints

Unlike CSS/browser layout, Emacs buffers have fundamental constraints:

- *Monospace*: All characters occupy the same width (mostly)
- *Linear*: Text flows left-to-right, top-to-bottom
- *No absolute positioning*: Can't place text at arbitrary x,y coordinates
- *No overlap*: Text can't overlap (overlays can, but not content)
- *Line-based*: Vertical positioning is in lines, not pixels

** Layout Primitives

*** Horizontal Stack

#+begin_src elisp
(defun vui-hstack (&rest args)
  "Create a horizontal stack layout.

ARGS can start with keyword options, followed by children.
Options:
  :spacing N  â€” spaces between children (default 1)
  :key KEY    â€” for reconciliation

Usage:
  (vui-hstack child1 child2 child3)
  (vui-hstack :spacing 2 child1 child2)"
  ...)
#+end_src

*** Vertical Stack

#+begin_src elisp
(defun vui-vstack (&rest args)
  "Create a vertical stack layout.

Options:
  :spacing N  â€” blank lines between children (default 0)
  :indent N   â€” left indent in spaces (default 0)
  :key KEY    â€” for reconciliation

Usage:
  (vui-vstack child1 child2 child3)
  (vui-vstack :spacing 1 child1 child2)
  (vui-vstack :indent 2 child1 child2)"
  ...)
#+end_src

*** Fixed-Width Box

#+begin_src elisp
(defun vui-box (child &rest props)
  "Create a fixed-width container.

CHILD is a single vnode.
PROPS:
  :width N          â€” width in characters (default 20)
  :align ALIGN      â€” :left, :center, :right (default :left)
  :padding-left N   â€” left padding (default 0)
  :padding-right N  â€” right padding (default 0)
  :key KEY

Usage:
  (vui-box (vui-text \"hello\") :width 20 :align :center)"
  ...)
#+end_src

*** Table

#+begin_src elisp
(defun vui-table (&rest args)
  "Create a table layout.

Column spec properties (each column is a plist):
  :header STRING  â€” Header text (optional)
  :width N        â€” Fixed width, overrides content measurement
  :min-width N    â€” Minimum width, expand for content (default 1)
  :align ALIGN    â€” :left (default), :center, :right
  :grow BOOL      â€” If t, enforce :width as minimum
  :truncate BOOL  â€” If t, truncate overflow; if nil, use overflow separator

Table properties:
  :columns LIST   â€” List of column specs
  :rows LIST      â€” List of rows, each row is list of cell contents
  :border MODE    â€” nil (default), :ascii, :unicode
  :key KEY

Cell contents can be strings or vnodes (including buttons).

Usage:
  (vui-table
    :columns '((:header \"Name\" :min-width 10)
               (:header \"Price\" :width 8 :align :right)
               (:header \"Qty\" :width 5 :align :right))
    :rows '((\"Apple\" \"$1.50\" \"10\")
            (\"Banana\" \"$0.75\" \"25\"))
    :border :ascii)"
  ...)
#+end_src

*** Dynamic List

For rendering lists of items with efficient reconciliation:

#+begin_src elisp
(cl-defun vui-list (items render-fn &optional key-fn &key (vertical t))
  "Render a list of ITEMS using RENDER-FN.

RENDER-FN is called with each item and should return a vnode.
KEY-FN extracts a unique key from each item (default: item itself).
VERTICAL if non-nil (default t), adds newlines between items.

This ensures proper reconciliation when items are added, removed,
or reordered.

Usage:
  (vui-list items
            (lambda (item) (vui-text (plist-get item :name)))
            (lambda (item) (plist-get item :id)))

  ;; Horizontal list (no newlines):
  (vui-list items render-fn key-fn :vertical nil)"
  ...)
#+end_src


* State Management

** Overview

State in vui.el follows React's model:

1. *Local state*: Owned by a component, triggers re-render when changed
2. *Props*: Passed from parent, read-only to child
3. *Context*: Shared across tree without prop drilling
4. *Effects*: Side effects triggered by state/prop changes

#+begin_example
         +-----------------+
         |   Root State    |
         |  (context)      |
         +--------+--------+
                  | context
         +--------v--------+
         |   Parent        |
         | +-------------+ |
         | | local state | |
         | +-------------+ |
         +--------+--------+
                  | props (â†“) + callbacks (â†‘)
         +--------v--------+
         |   Child         |
         | +-------------+ |
         | | local state | |
         | +-------------+ |
         +-----------------+
#+end_example

** State Updates

#+begin_src elisp
(defun vui-set-state (key value)
  "Set state KEY to VALUE and trigger re-render.

Must be called from within a component context (event handler,
effect, or lifecycle hook).

If VALUE is a function, it's called with the current value and
the result is used. This avoids stale closure problems:

  ;; Direct value
  (vui-set-state :count 5)

  ;; Functional update (recommended in async contexts)
  (vui-set-state :count #'1+)
  (vui-set-state :items (lambda (old) (cons new-item old)))"
  ...)
#+end_src

** Batching Updates

#+begin_src elisp
(defmacro vui-batch (&rest body)
  "Batch state updates in BODY into a single re-render.

Without batching, each vui-set-state triggers a separate render.
With batching, all updates are applied, then one render occurs.

Example:
  (vui-batch
    (vui-set-state :name \"Bob\")
    (vui-set-state :count 0)
    (vui-set-state :items nil))"
  ...)

(defun vui-flush-sync ()
  "Force immediate re-render, bypassing any pending timers.

Use when you need the UI to update synchronously."
  ...)
#+end_src

** Async Context Helpers

When updating state from async callbacks (timers, processes), you need to capture the component context:

#+begin_src elisp
(defmacro vui-with-async-context (&rest body)
  "Capture component context for use in async callbacks.

Returns a function that restores context and executes BODY.
Automatically checks if buffer is still alive.

Example:
  (run-with-timer 1 1
    (vui-with-async-context
      (vui-set-state :count #'1+)))"
  ...)

(defmacro vui-async-callback (args &rest body)
  "Like vui-with-async-context but accepts arguments.

Use when the async operation passes data to the callback.

Example:
  (make-process
    :sentinel (vui-async-callback (proc event)
                (when (eq (process-status proc) 'exit)
                  (vui-set-state :result (process-output proc)))))"
  ...)
#+end_src


* Hooks

** Effects

#+begin_src elisp
(defmacro use-effect (deps &rest body)
  "Run BODY as a side effect when DEPS change.

DEPS is a list of variables to watch. The effect runs:
- After first render
- After re-render if any dep changed (compared with `equal')

If BODY returns a function, it's called as cleanup before
the next effect run or on unmount.

Examples:
  ;; Run once on mount (empty deps)
  (use-effect ()
    (message \"Component mounted\"))

  ;; Run when count changes
  (use-effect (count)
    (message \"Count is now %d\" count))

  ;; With cleanup
  (use-effect (user-id)
    (let ((subscription (subscribe user-id)))
      (lambda () (unsubscribe subscription))))"
  ...)
#+end_src

** Refs

#+begin_src elisp
(defmacro use-ref (initial-value)
  "Create a mutable ref that persists across re-renders.

Returns a cons cell whose car is the current value.
Access via (car ref), set via (setcar ref new-value).

Unlike state, modifying a ref does NOT trigger re-render.

Useful for:
- Storing timer/process references for cleanup
- Tracking previous values
- Mutable values that don't affect rendering

Example:
  (let ((timer-ref (use-ref nil)))
    (use-effect ()
      (setcar timer-ref (run-with-timer 1 1 #'update))
      (lambda () (cancel-timer (car timer-ref)))))"
  ...)
#+end_src

** Memoised Callbacks

#+begin_src elisp
(defmacro use-callback (deps &rest body)
  "Create a memoised callback that only changes when DEPS change.

Returns a stable function reference across re-renders as long
as DEPS don't change. Useful for preventing unnecessary child
re-renders when passing callbacks as props.

Example:
  (let ((handler (use-callback (item-id)
                   (delete-item item-id))))
    (vui-button \"Delete\" :on-click handler))"
  ...)

(defmacro use-callback* (deps &key compare &rest body)
  "Like use-callback but with configurable comparison.

COMPARE can be:
  'eq     â€” identity comparison (fast)
  'equal  â€” structural comparison (default)
  function â€” custom (lambda (old-deps new-deps) bool)"
  ...)
#+end_src

** Memoised Values

#+begin_src elisp
(defmacro use-memo (deps &rest body)
  "Compute and cache a value that only changes when DEPS change.

BODY is evaluated only when DEPS change; the result is cached.

Example:
  (let ((filtered (use-memo (items filter)
                    (seq-filter predicate items))))
    (vui-list filtered #'render-item))"
  ...)

(defmacro use-memo* (deps &key compare &rest body)
  "Like use-memo but with configurable comparison."
  ...)
#+end_src

** Async Data Loading

#+begin_src elisp
(defmacro use-async (key loader)
  "Asynchronously load data using LOADER, identified by KEY.

Returns a plist with:
  :status â€” One of 'pending, 'ready, or 'error
  :data   â€” The loaded data (when status is 'ready)
  :error  â€” The error message (when status is 'error)

KEY should uniquely identify this async operation. When KEY
changes, the previous load is cancelled and a new one starts.

LOADER is (lambda (resolve reject) ...) where:
- Call (funcall resolve data) on success
- Call (funcall reject error-message) on failure

Example:
  (let ((result (use-async (list 'user user-id)
                  (lambda (resolve reject)
                    (fetch-user user-id resolve reject)))))
    (pcase (plist-get result :status)
      ('pending (vui-text \"Loading...\"))
      ('error (vui-text (plist-get result :error) :face 'error))
      ('ready (render-user (plist-get result :data)))))"
  ...)
#+end_src


* Context System

** Creating a Context

#+begin_src elisp
(defmacro defcontext (name &optional default-value docstring)
  "Define a context NAME with optional DEFAULT-VALUE.

Creates:
- `NAME-context': The context object
- `NAME-provider': Function to create a provider vnode
- `use-NAME': Function to consume the context value

Example:
  (defcontext theme 'light \"The current UI theme.\")"
  ...)
#+end_src

** Using Context

#+begin_src elisp
;; Define
(defcontext theme 'light)

;; Provide (wrap children with value)
(theme-provider 'dark
  (vui-component 'my-app))

;; Consume (in any descendant)
(let ((theme (use-theme)))
  (vui-text "Hello" :face (if (eq theme 'dark) 'bold 'default)))
#+end_src

** When to Use Context

Use *props* when:
- Data is needed by immediate children
- Explicit data flow is clearer
- Component reusability is important

Use *context* when:
- Data is needed by many components at different levels
- Data changes infrequently (theme, locale, auth)
- Prop drilling would be excessive (>3 levels)

* Lifecycle Hooks

** Overview

#+begin_example
+--------------------------------------------------+
|                      MOUNTING                    |
|  1. Create instance                              |
|  2. Initialise state (initial-state-fn)          |
|  3. Render (render-fn)                           |
|  4. Commit to buffer                             |
|  5. Run use-effect callbacks                     |
|  6. Call on-mount (return value stored as cleanup)|
+--------------------------------------------------+
                          |
                          v
+--------------------------------------------------+
|                 UPDATING (repeated)              |
|  1. Receive new props or state change            |
|  2. Check should-update (skip if nil)            |
|  3. Render (render-fn)                           |
|  4. Commit to buffer                             |
|  5. Run effect cleanups for changed deps         |
|  6. Run effects for changed deps                 |
|  7. Call on-update (with prev-props, prev-state) |
+--------------------------------------------------+
                          |
                          v
+--------------------------------------------------+
|                     UNMOUNTING                   |
|  1. Run all effect cleanups                      |
|  2. Call mount-cleanup (from on-mount return)    |
|  3. Call on-unmount                              |
|  4. Remove from buffer                           |
+--------------------------------------------------+
#+end_example

** Hook Ordering

- *Mount*: Children mount before parent (bottom-up)
- *Update*: Children update before parent (bottom-up)
- *Unmount*: Children unmount before parent (bottom-up)

This ensures a parent's hooks can safely interact with mounted children.

* Error Handling

** Error Boundary

#+begin_src elisp
(cl-defun vui-error-boundary (&key fallback on-error id children)
  "Create an error boundary that catches errors in CHILDREN.

FALLBACK is (lambda (error) vnode) â€” what to render on error.
ON-ERROR is optional (lambda (error)) â€” for logging.
ID is a unique identifier for this boundary.
CHILDREN are the vnodes to render normally.

Example:
  (vui-error-boundary
    :id 'my-boundary
    :fallback (lambda (err)
                (vui-vstack
                  (vui-text (format \"Error: %s\" err) :face 'error)
                  (vui-button \"Retry\"
                    :on-click (lambda ()
                                (vui-reset-error-boundary 'my-boundary)))))
    :children (list (risky-component)))"
  ...)

(defun vui-reset-error-boundary (id)
  "Clear error state for boundary ID and trigger re-render.

Call this to retry rendering after an error."
  ...)
#+end_src

** Error Handler Configuration

#+begin_src elisp
(defcustom vui-lifecycle-error-handler 'warn
  "How to handle errors in lifecycle hooks.

Values:
  'warn    â€” Display warning (default)
  'message â€” Display in echo area
  'signal  â€” Re-signal the error
  'ignore  â€” Silently ignore
  function â€” Custom (lambda (hook-name error instance))"
  ...)

(defcustom vui-event-error-handler 'warn
  "How to handle errors in event callbacks (on-click, etc.)."
  ...)

(defvar vui-last-error nil
  "Most recent error: (TYPE ERROR CONTEXT).")
#+end_src

* Debugging Tools

** Component Inspector

#+begin_src elisp
(defun vui-inspect (&optional instance)
  "Display component tree with props and state.

Shows hierarchy, current props, and state for each component.
Opens *vui-inspector* buffer."
  ...)

(defun vui-inspect-state (&optional instance)
  "Display focused view of state across all components.

Opens *vui-state* buffer."
  ...)

(defun vui-get-instance-by-id (id &optional instance)
  "Find instance with ID."
  ...)

(defun vui-get-component-instances (component-type &optional instance)
  "Find all instances of COMPONENT-TYPE."
  ...)
#+end_src

** Debug Logging

#+begin_src elisp
(defcustom vui-debug-enabled nil
  "When non-nil, log debug info to *vui-debug* buffer."
  ...)

(defcustom vui-debug-log-phases '(render mount update unmount state-change)
  "Which phases to log."
  ...)

(defun vui-debug-show ()
  "Show the *vui-debug* buffer."
  ...)

(defun vui-debug-clear ()
  "Clear the debug log."
  ...)
#+end_src

** Timing Instrumentation

#+begin_src elisp
(defcustom vui-timing-enabled nil
  "When non-nil, collect timing data for render phases."
  ...)

(defun vui-report-timing (&optional last-n)
  "Display timing report grouped by component and phase."
  ...)

(defun vui-clear-timing ()
  "Clear collected timing data."
  ...)
#+end_src

* API Reference

** Component Definition

#+begin_src elisp
(defcomponent NAME (PROP1 PROP2 ...)
  [:state ((VAR INITIAL) ...)]
  [:on-mount FORM]
  [:on-update FORM]
  [:on-unmount FORM]
  [:should-update FORM]
  :render FORM)
#+end_src

** Primitive VNodes

| Function                          | Description        | Key Props                                       |
|-----------------------------------+--------------------+-------------------------------------------------|
| =(vui-text CONTENT &rest PROPS)=  | Plain text         | =:face=, =:key=                                 |
| =(vui-button LABEL &rest PROPS)=  | Clickable button   | =:on-click=, =:face=, =:disabled=, =:max-width=, =:no-decoration=, =:help-echo= |
| =(vui-field &key VALUE SIZE ...)= | Editable field     | =:on-change=, =:on-submit=, =:secret=           |
| =(vui-checkbox &rest PROPS)=      | Boolean toggle     | =:checked=, =:on-change=, =:label=              |
| =(vui-select &rest PROPS)=        | Dropdown selection | =:value=, =:options=, =:on-change=, =:prompt=   |
| =(vui-newline)=                   | Line break         |                                                 |
| =(vui-space &optional WIDTH)=     | Horizontal space   |                                                 |
| =(vui-fragment &rest CHILDREN)=   | Group without wrap |                                                 |

** Layout VNodes

| Function                  | Description           | Key Props                        |
|---------------------------+-----------------------+----------------------------------|
| =(vui-hstack &rest ARGS)= | Horizontal layout     | =:spacing=                       |
| =(vui-vstack &rest ARGS)= | Vertical layout       | =:spacing=, =:indent=            |
| =(vui-box CHILD ...)=     | Fixed-width container | =:width=, =:align=, =:padding-*= |
| =(vui-table ...)=         | Table layout          | =:columns=, =:rows=, =:border=   |
| =(vui-list ITEMS FN ...)= | Dynamic list          | =KEY-FN=, =:vertical=            |

** Hooks

| Macro/Function             | Purpose                    |
|----------------------------+----------------------------|
| =(use-effect DEPS ...)=    | Side effects on dep change |
| =(use-ref INITIAL)=        | Mutable ref (no re-render) |
| =(use-callback DEPS ...)=  | Stable callback reference  |
| =(use-callback* DEPS ...)= | With custom comparison     |
| =(use-memo DEPS ...)=      | Cached computation         |
| =(use-memo* DEPS ...)=     | With custom comparison     |
| =(use-async KEY LOADER)=   | Async data loading         |

** State

| Function/Macro                  | Purpose                       |
|---------------------------------+-------------------------------|
| =(vui-set-state KEY VALUE)=     | Update state, trigger render  |
| =(vui-batch ...)=               | Batch updates into one render |
| =(vui-flush-sync)=              | Force immediate render        |
| =(vui-with-async-context ...)=  | Capture context for async     |
| =(vui-async-callback ARGS ...)= | Async callback with args      |

** Context

| Macro/Function              | Purpose               |
|-----------------------------+-----------------------|
| =(defcontext NAME DEFAULT)= | Define a context      |
| =(NAME-provider VALUE ...)= | Provide context value |
| =(use-NAME)=                | Consume context value |

** Rendering

| Function                     | Purpose                     |
|------------------------------+-----------------------------|
| =(vui-mount VNODE [BUFFER])= | Mount tree, return instance |
| =(vui-component TYPE ...)=   | Create component vnode      |

** Error Handling

| Function                        | Purpose                   |
|---------------------------------+---------------------------|
| =(vui-error-boundary ...)=      | Catch errors in children  |
| =(vui-reset-error-boundary ID)= | Clear error, retry render |

** Debugging

| Function/Variable     | Purpose                       |
|-----------------------+-------------------------------|
| =(vui-inspect)=       | Show component tree           |
| =(vui-inspect-state)= | Show state across tree        |
| =vui-debug-enabled=   | Enable debug logging          |
| =(vui-debug-show)=    | Show debug buffer             |
| =vui-timing-enabled=  | Enable timing instrumentation |
| =(vui-report-timing)= | Show timing report            |


* Implementation Status

** Achieved

| Category         | Feature                                    | Status |
|------------------+--------------------------------------------+--------|
| *Core*           | =defcomponent= macro                       | âœ“      |
|                  | Props and state management                 | âœ“      |
|                  | =vui-set-state= with functional updates    | âœ“      |
|                  | =vui-mount=                                | âœ“      |
| *Primitives*     | =vui-text=, =vui-button=, =vui-field=      | âœ“      |
|                  | =vui-newline=, =vui-space=, =vui-fragment= | âœ“      |
|                  | =vui-checkbox=, =vui-select=               | âœ“      |
| *Layout*         | =vui-hstack=, =vui-vstack=, =vui-box=      | âœ“      |
|                  | =vui-table= (borders, alignment)           | âœ“      |
|                  | =vui-list= (dynamic rendering with keys)   | âœ“      |
| *Hooks*          | =use-effect= with cleanup                  | âœ“      |
|                  | =use-ref=, =use-callback=, =use-memo=      | âœ“      |
|                  | =use-callback*=, =use-memo*= (custom cmp)  | âœ“      |
|                  | =use-async=                                | âœ“      |
| *Context*        | =defcontext= macro                         | âœ“      |
|                  | Provider vnodes, =use-NAME= consumption    | âœ“      |
| *Lifecycle*      | =on-mount=, =on-update=, =on-unmount=      | âœ“      |
|                  | =on-mount= cleanup return                  | âœ“      |
| *Async*          | =vui-with-async-context=                   | âœ“      |
|                  | =vui-async-callback=                       | âœ“      |
| *Optimisation*   | =should-update= predicate                  | âœ“      |
|                  | =vui-batch=, =vui-flush-sync=              | âœ“      |
|                  | =vui-render-delay= (idle rendering)        | âœ“      |
|                  | =vui-timing-enabled= instrumentation       | âœ“      |
| *Error*          | =vui-error-boundary=                       | âœ“      |
|                  | =vui-reset-error-boundary=                 | âœ“      |
|                  | Configurable error handlers                | âœ“      |
| *Dev Tools*      | =vui-inspect=, =vui-inspect-state=         | âœ“      |
|                  | =vui-debug-enabled=, debug logging         | âœ“      |
| *Reconciliation* | Key-based matching                         | âœ“      |
|                  | Cursor preservation (widget indexing)      | âœ“      |


* Appendix A: Comparison with widget.el

| Aspect      | widget.el            | vui.el                   |
|-------------+----------------------+--------------------------|
| Model       | Imperative           | Declarative              |
| Updates     | Manual create/delete | Automatic reconciliation |
| State       | Mixed with widget    | Explicit, separated      |
| Composition | Format strings       | Tree structure           |
| Lifecycle   | Implicit             | Explicit hooks           |
| Cursor      | Per-widget handling  | Automatic preservation   |


* Appendix B: Example Applications

** B.1 Todo Application

#+begin_src elisp
(defcomponent todo-item (todo on-toggle on-delete)
  :render
  (vui-hstack
   (vui-button (if (plist-get todo :done) "[x]" "[ ]")
     :on-click (lambda () (funcall on-toggle (plist-get todo :id))))
   (vui-text (plist-get todo :text)
     :face (when (plist-get todo :done) 'shadow))
   (vui-button "Ã—"
     :on-click (lambda () (funcall on-delete (plist-get todo :id))))))

(defcomponent todo-list ()
  :state ((todos nil)
          (new-text ""))

  :render
  (vui-vstack
   ;; Input row
   (vui-hstack
    (vui-field :value new-text :size 30
      :on-change (lambda (v) (vui-set-state :new-text v)))
    (vui-button "Add"
      :on-click (lambda ()
                  (when (not (string-empty-p new-text))
                    (vui-batch
                      (vui-set-state :todos
                        (lambda (old)
                          (cons (list :id (cl-gensym)
                                      :text new-text
                                      :done nil)
                                old)))
                      (vui-set-state :new-text ""))))))

   ;; List of todos
   (vui-list todos
     (lambda (todo)
       (vui-component 'todo-item
         :todo todo
         :on-toggle (lambda (id)
                      (vui-set-state :todos
                        (lambda (old)
                          (mapcar (lambda (t)
                                    (if (eq (plist-get t :id) id)
                                        (plist-put (copy-sequence t) :done
                                                   (not (plist-get t :done)))
                                      t))
                                  old))))
         :on-delete (lambda (id)
                      (vui-set-state :todos
                        (lambda (old)
                          (cl-remove-if
                           (lambda (t) (eq (plist-get t :id) id))
                           old))))))
     (lambda (todo) (plist-get todo :id)))

   ;; Summary
   (vui-text (format "%d items, %d completed"
                     (length todos)
                     (cl-count-if (lambda (t) (plist-get t :done)) todos))
     :face 'shadow)))

;; Mount
(vui-mount (vui-component 'todo-list))
#+end_src

** B.2 File Browser

#+begin_src elisp
(defcomponent file-item (path on-select)
  :render
  (let ((name (file-name-nondirectory path))
        (is-dir (file-directory-p path)))
    (vui-hstack
     (vui-text (if is-dir "ðŸ“ " "ðŸ“„ "))
     (vui-button name
       :on-click (lambda () (funcall on-select path))))))

(defcomponent file-browser (root)
  :state ((current-dir nil)
          (selected nil))

  :on-mount
  (vui-set-state :current-dir root)

  :render
  (let ((entries (when current-dir
                   (directory-files current-dir t "^[^.]"))))
    (vui-vstack
     ;; Breadcrumb
     (vui-hstack
      (vui-button "â†‘"
        :on-click (lambda ()
                    (vui-set-state :current-dir
                      (file-name-directory
                       (directory-file-name current-dir)))))
      (vui-text (or current-dir "") :face 'bold))

     (vui-text (make-string 40 ?â”€) :face 'shadow)

     ;; File list
     (when entries
       (vui-list entries
         (lambda (path)
           (vui-component 'file-item
             :path path
             :on-select (lambda (p)
                          (if (file-directory-p p)
                              (vui-set-state :current-dir p)
                            (vui-set-state :selected p)))))
         #'identity))

     ;; Selection
     (when selected
       (vui-vstack
        (vui-text (make-string 40 ?â”€) :face 'shadow)
        (vui-text (format "Selected: %s" selected) :face 'success))))))

;; Mount
(vui-mount (vui-component 'file-browser :root "~/"))
#+end_src


* Appendix C: Naming Conventions

| Prefix          | Meaning                |
|-----------------+------------------------|
| =vui-=          | Public API             |
| =vui--=         | Internal/private       |
| =vui-vnode-=    | Virtual node types     |
| =vui-instance-= | Instance accessors     |
| =use-=          | Hooks (call in render) |
| =def=           | Definition forms       |


* Appendix D: Future Ideas

These features were considered during design but are not currently implemented.
They may be added in future versions if needed.

** D.1 Binding Forms

*let-state*: A binding form with =setf= support for state:

#+begin_src elisp
;; Hypothetical syntax
(let-state ((count 0))
  (vui-button "+" :on-click (lambda () (cl-incf count))))
#+end_src

Currently, use =vui-set-state= explicitly.

*let-memo*: A binding form for memoised values:

#+begin_src elisp
;; Hypothetical syntax
(let-memo ((filtered (items filter)
             (seq-filter pred items)))
  ...)
#+end_src

Currently, use =use-memo= macro.

** D.2 Reducer Pattern

A =use-reducer= hook for complex state logic:

#+begin_src elisp
;; Hypothetical syntax
(let* ((result (use-reducer #'my-reducer initial-state))
       (state (car result))
       (dispatch (cdr result)))
  (vui-button "+" :on-click (lambda () (dispatch '(:type increment)))))
#+end_src

** D.3 Hidden Component

A =vui-hidden= component that hides children without unmounting:

#+begin_src elisp
;; Hypothetical syntax
(vui-hidden show-details
  (detail-panel :data data))
#+end_src

Unlike =(when show-details ...)=, the instance would be preserved when hidden, maintaining state and running effects.

** D.4 Multi-line Content in Horizontal Layouts

Supporting multi-line children in =vui-hstack= with proper column alignment:

#+begin_example
| comp1 | comp2.1 | comp3 |
|       | comp2.2 |       |
#+end_example

This would require two-pass rendering (measure then render).

** D.5 Responsive Layout

Window-width-aware layout selection:

#+begin_src elisp
;; Hypothetical syntax
(vui-responsive
  (>= (window-width) 80) (wide-layout)
  (>= (window-width) 40) (medium-layout)
  t (narrow-layout))
#+end_src

Would need hooks into =window-size-change-functions=.

** D.6 Animation

Transition effects on show/hide or content changes, using idle timers and overlay manipulation.

** D.7 Transient Integration

Integration with =transient.el= for complex keyboard-driven menus.

** D.8 State Serialisation

Serialising/deserialising component tree state for session persistence.
