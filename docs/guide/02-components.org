#+TITLE: Components
#+AUTHOR: vui.el Documentation
#+OPTIONS: toc:2 num:t

Components are the building blocks of vui.el applications. This guide covers everything you need to know about defining, composing, and working with components.

* What is a Component?

A component is a reusable piece of UI with its own:

- *Props* - Input data from parent
- *State* - Internal data that can change over time
- *Render function* - Describes what to display

#+begin_src elisp
(defcomponent my-component (prop1 prop2)   ; Props
  :state ((local-value "initial"))          ; State
  :render                                   ; Render function
  (vui-text (format "%s - %s" prop1 local-value)))
#+end_src

* Defining Components with =defcomponent=

The =defcomponent= macro is the primary way to create components:

#+begin_src elisp
(defcomponent name (prop-list)
  :state ((state-var initial-value) ...)
  :render body
  :on-mount body
  :on-update body
  :on-unmount body
  :should-update body)
#+end_src

** Component Name

The name must be a symbol. By convention, use lowercase with hyphens:

#+begin_src elisp
(defcomponent user-profile ...)     ; Good
(defcomponent UserProfile ...)      ; Works, but not idiomatic
(defcomponent "user-profile" ...)   ; Error: must be a symbol
#+end_src

** Props (Arguments)

Props are the component's public interface - data passed from parent components.

*** Simple Props

#+begin_src elisp
(defcomponent greeting (name)
  :render (vui-text (format "Hello, %s!" name)))

;; Usage:
(vui-component 'greeting :name "Alice")
#+end_src

*** Multiple Props

#+begin_src elisp
(defcomponent user-badge (name role &optional avatar)
  :render
  (vui-hstack
   (when avatar (vui-text avatar))
   (vui-text name)
   (vui-text (format "[%s]" role) :face 'shadow)))

;; Usage:
(vui-component 'user-badge :name "Alice" :role "Admin" :avatar "ðŸ‘¤")
(vui-component 'user-badge :name "Bob" :role "User")  ; avatar is nil
#+end_src

*** Props are Read-Only

Props should never be modified inside a component. They flow down from the parent. If you need to modify a value, use state instead.

#+begin_src elisp
;; DON'T do this:
(defcomponent bad-example (value)
  :render
  (progn
    (setq value (1+ value))  ; WRONG! Never modify props
    (vui-text (number-to-string value))))

;; DO this instead:
(defcomponent good-example (initial-value)
  :state ((value initial-value))  ; Copy to state if you need to modify
  :render
  (vui-text (number-to-string value)))
#+end_src

** State

State is internal data that belongs to the component. When state changes, the component re-renders.

*** Declaring State

#+begin_src elisp
(defcomponent counter ()
  :state ((count 0)           ; Integer starting at 0
          (name "Counter")    ; String
          (items '()))        ; Empty list
  :render ...)
#+end_src

Each state variable is a pair: =(name initial-value)=.

*** Accessing State

State variables are available directly in the render function:

#+begin_src elisp
(defcomponent status-display ()
  :state ((status "ready")
          (count 0))
  :render
  (vui-text (format "Status: %s (count: %d)" status count)))
#+end_src

*** Updating State with =vui-set-state=

#+begin_src elisp
(defcomponent counter ()
  :state ((count 0))
  :render
  (vui-fragment
   (vui-text (format "Count: %d" count))
   (vui-newline)
   (vui-button "Increment"
               :on-click (lambda ()
                           (vui-set-state :count (1+ count))))
   (vui-button "Reset"
               :on-click (lambda ()
                           (vui-set-state :count 0)))))
#+end_src

=vui-set-state= takes a keyword (=:count=) and a new value. It automatically triggers a re-render with the updated state.

*** State is Local

Each component instance has its own state:

#+begin_src elisp
(defcomponent counter ()
  :state ((count 0))
  :render
  (vui-button (format "Count: %d" count)
              :on-click (lambda () (vui-set-state :count (1+ count)))))

;; These are independent:
(vui-fragment
 (vui-component 'counter)  ; Has its own count
 (vui-component 'counter)  ; Has its own count
 (vui-component 'counter)) ; Has its own count
#+end_src

* The Render Function

The =:render= body defines what the component displays. It must return a vnode (or =nil= for nothing).

** Pure Rendering

The render function should be /pure/ - it should only compute the UI based on props and state, with no side effects.

#+begin_src elisp
;; Good: Pure render function
(defcomponent pure-example ()
  :state ((value 0))
  :render
  (vui-text (number-to-string value)))

;; Bad: Side effects in render
(defcomponent impure-example ()
  :state ((value 0))
  :render
  (progn
    (message "Rendering!")  ; Side effect - avoid this!
    (vui-text (number-to-string value))))
#+end_src

Use lifecycle hooks (=:on-mount=, =:on-update=) for side effects instead.

** Conditional Rendering

Use regular Lisp control flow:

#+begin_src elisp
(defcomponent conditional-example (logged-in user-name)
  :render
  (if logged-in
      (vui-text (format "Welcome, %s!" user-name))
    (vui-text "Please log in")))
#+end_src

** Rendering Lists

Use =vui-list= for dynamic lists, or =cl-loop= for static ones:

#+begin_src elisp
;; Dynamic list (items can change)
(defcomponent item-list ()
  :state ((items '("Apple" "Banana" "Cherry")))
  :render
  (vui-list items
            (lambda (item)
              (vui-text (format "â€¢ %s\n" item)))))

;; Static list in render
(defcomponent static-list ()
  :render
  (vui-fragment
   (cl-loop for item in '("One" "Two" "Three")
            collect (vui-fragment
                     (vui-text (format "- %s" item))
                     (vui-newline)))))
#+end_src

** Returning nil

If you return =nil=, nothing is rendered:

#+begin_src elisp
(defcomponent maybe-show (show-p message)
  :render
  (when show-p
    (vui-text message)))  ; Returns nil when show-p is false
#+end_src

* Creating Component Instances

Use =vui-component= to create a component vnode:

#+begin_src elisp
(vui-component 'component-name
               :prop1 value1
               :prop2 value2
               child1 child2 ...)
#+end_src

** Passing Props

Props are passed as keyword arguments:

#+begin_src elisp
(vui-component 'user-card
               :name "Alice"
               :email "alice@example.com"
               :role 'admin)
#+end_src

** Passing Children

Non-keyword arguments after props become the =children= prop:

#+begin_src elisp
(defcomponent card (title)
  :render
  (vui-fragment
   (vui-text (format "=== %s ===" title))
   (vui-newline)
   children  ; Render passed children
   (vui-newline)
   (vui-text "============")))

;; Usage:
(vui-component 'card :title "My Card"
               (vui-text "Card content goes here"))
#+end_src

** Keys for Reconciliation

When rendering lists of components, use =:key= to help vui.el track them:

#+begin_src elisp
(defcomponent todo-list ()
  :state ((todos '((:id 1 :text "First")
                   (:id 2 :text "Second"))))
  :render
  (vui-fragment
   (cl-loop for todo in todos
            collect (vui-component 'todo-item
                                   :key (plist-get todo :id)  ; Unique key
                                   :todo todo))))
#+end_src

Keys should be stable, unique identifiers (not array indices).

* Component Composition

Components can use other components:

#+begin_src elisp
(defcomponent button-group ()
  :render
  (vui-hstack
   (vui-component 'fancy-button :label "Save")
   (vui-component 'fancy-button :label "Cancel")))

(defcomponent fancy-button (label)
  :render
  (vui-button (format "[ %s ]" label)))
#+end_src

** Lifting State Up

When multiple components need to share state, lift it to a common ancestor:

#+begin_src elisp
;; Parent owns the state
(defcomponent temperature-app ()
  :state ((celsius 0))
  :render
  (vui-fragment
   (vui-component 'temperature-input
                  :label "Celsius"
                  :value celsius
                  :on-change (lambda (v) (vui-set-state :celsius v)))
   (vui-newline)
   (vui-component 'temperature-input
                  :label "Fahrenheit"
                  :value (+ 32 (* celsius 1.8))
                  :on-change (lambda (v)
                               (vui-set-state :celsius
                                              (/ (- v 32) 1.8))))))

;; Child is stateless, calls parent's callback
(defcomponent temperature-input (label value on-change)
  :render
  (vui-hstack
   (vui-text (format "%s: " label))
   (vui-field :value (format "%.1f" value)
              :size 10
              :on-change (lambda (new-val)
                           (funcall on-change (string-to-number new-val))))))
#+end_src

* Mounting Components

=vui-mount= renders a component to a buffer:

#+begin_src elisp
(vui-mount (vui-component 'my-app) "*my-app*")
#+end_src

The buffer is created if it doesn't exist. The component becomes the "root" of that buffer's UI tree.

** Multiple Roots

Each buffer can have one root component. For multiple independent UIs, use multiple buffers:

#+begin_src elisp
(vui-mount (vui-component 'sidebar) "*sidebar*")
(vui-mount (vui-component 'main-view) "*main*")
#+end_src

* Try It Yourself

#+begin_quote
*Exercise*: Create a =collapsible-section= component that:

1. Takes =title= and =children= props
2. Has =expanded= state (initially =t=)
3. Shows a toggle button (=[-]= when expanded, =[+]= when collapsed)
4. Only shows children when expanded
#+end_quote

#+begin_src elisp
;; Your solution:
(defcomponent collapsible-section (title)
  :state ((expanded t))
  :render
  ;; ... implement this
  )

;; Test it:
(vui-mount
 (vui-component 'collapsible-section :title "Details"
                (vui-text "Line 1")
                (vui-newline)
                (vui-text "Line 2"))
 "*test-collapsible*")
#+end_src

* What's Next?

- [[file:03-primitives.org][Primitives]] - Learn about all built-in UI elements
- [[file:07-lifecycle.org][Lifecycle]] - on-mount, on-update, on-unmount hooks
- [[file:06-context.org][Context]] - Share data without prop drilling
