#+TITLE: Primitives
#+AUTHOR: vui.el Documentation
#+OPTIONS: toc:2 num:t

Primitives are the basic building blocks for creating UIs in vui.el. They represent the fundamental elements that can be rendered to a buffer.

* Text Display

** =vui-text= - Display Text

The most basic primitive. Displays text content.

#+begin_src elisp
(vui-text "Hello, World!")
#+end_src

*** With Face (Styling)

#+begin_src elisp
(vui-text "Error: Something went wrong" :face 'error)
(vui-text "Success!" :face 'success)
(vui-text "Dimmed text" :face 'shadow)
#+end_src

*** With Text Properties

#+begin_src elisp
(vui-text "Important" :face '(:weight bold :foreground "red"))
#+end_src

*** With Key (for Reconciliation)

#+begin_src elisp
(vui-text "Status message" :key "status")
#+end_src

*** Plain Strings

For convenience, plain strings are automatically treated as text:

#+begin_src elisp
(vui-fragment
 "This is plain text"      ; Same as (vui-text "This is plain text")
 (vui-newline)
 "More text")
#+end_src

** =vui-newline= - Line Break

Inserts a newline character:

#+begin_src elisp
(vui-fragment
 (vui-text "Line 1")
 (vui-newline)
 (vui-text "Line 2"))
#+end_src

Output:
#+begin_example
Line 1
Line 2
#+end_example

** =vui-space= - Horizontal Space

Inserts whitespace:

#+begin_src elisp
(vui-space)      ; Default: 1 space
(vui-space 5)    ; 5 spaces
#+end_src

* Interactive Elements

All interactive elements (buttons, fields, checkboxes, selects) support keyboard navigation with =TAB= / =S-TAB= to move between them.

** =vui-button= - Clickable Button

Creates a button that responds to user activation (=RET= or mouse click). Buttons are rendered with brackets: =LABEL= becomes =[LABEL]=.

#+begin_src elisp
(vui-button "Click me"
            :on-click (lambda () (message "Clicked!")))
#+end_src

Output:
#+begin_example
[Click me]
#+end_example

*** Button Properties

| Property      | Description                              |
|---------------+------------------------------------------|
| =:on-click=   | Callback when activated                  |
| =:face=       | Button face/styling                      |
| =:disabled=   | When non-nil, button is inactive         |
| =:max-width=  | Maximum width including brackets         |
| =:key=        | Key for reconciliation                   |

*** Disabled Button

Disabled buttons render as plain text (still with brackets) and don't respond to clicks:

#+begin_src elisp
(vui-button "Submit"
            :on-click #'do-submit
            :disabled (not form-valid))
#+end_src

Output (when disabled):
#+begin_example
[Submit]
#+end_example

*** Styled Button

#+begin_src elisp
(vui-button "Danger!"
            :on-click #'dangerous-action
            :face '(:foreground "red" :weight bold))
#+end_src

*** Truncated Button

When =:max-width= is set and the button label (including brackets) exceeds that width, the label is truncated with "...":

#+begin_src elisp
(vui-button "Very long button label"
            :max-width 15
            :on-click #'action)
#+end_src

Output:
#+begin_example
[Very long b...]
#+end_example

This is particularly useful in table cells with =:truncate= enabled, where the
column width is passed automatically to button children.

** =vui-field= - Text Input

Creates an editable text field:

#+begin_src elisp
(vui-field :value current-name
           :on-change (lambda (new-value)
                        (vui-set-state :name new-value)))
#+end_src

*** Field Properties

| Property     | Description                         |
|--------------+-------------------------------------|
| =:value=     | Current field value (string)        |
| =:on-change= | Callback with new value when edited |
| =:on-submit= | Callback when RET pressed in field  |
| =:size=      | Field width in characters           |
| =:key=       | Key for reconciliation              |

*** Field with Size

#+begin_src elisp
(vui-field :value email
           :size 30
           :on-change (lambda (v) (vui-set-state :email v)))
#+end_src

*** Submit Handling

#+begin_src elisp
(vui-field :value search-term
           :on-change (lambda (v) (vui-set-state :search-term v))
           :on-submit (lambda () (do-search search-term)))
#+end_src

*** Reading Field Value

In event handlers, use =vui-field-value= to read the current field value:

#+begin_src elisp
(defcomponent search-form ()
  :state ((query ""))
  :render
  (vui-hstack
   (vui-field :key "search-input"
              :value query
              :size 20
              :on-change (lambda (v) (vui-set-state :query v)))
   (vui-button "Search"
               :on-click (lambda ()
                           (let ((value (vui-field-value "search-input")))
                             (message "Searching for: %s" value))))))
#+end_src

** =vui-checkbox= - Toggle Checkbox

Creates a checkbox that can be toggled:

#+begin_src elisp
(vui-checkbox :checked enabled
              :label "Enable feature"
              :on-change (lambda (new-value)
                           (vui-set-state :enabled new-value)))
#+end_src

*** Checkbox Properties

| Property     | Description                           |
|--------------+---------------------------------------|
| =:checked=   | Boolean, whether checked              |
| =:label=     | Optional label text after checkbox    |
| =:on-change= | Callback with new boolean value       |
| =:key=       | Key for reconciliation                |

*** Without Label

#+begin_src elisp
(vui-hstack
 (vui-checkbox :checked done
               :on-change (lambda (v) (vui-set-state :done v)))
 (vui-text task-name))
#+end_src

** =vui-select= - Dropdown Selection

Creates a selection from a list of options:

#+begin_src elisp
(vui-select :value current-value
            :options '("Option 1" "Option 2" "Option 3")
            :on-change (lambda (new-value)
                         (vui-set-state :selection new-value)))
#+end_src

*** Select Properties

| Property     | Description                           |
|--------------+---------------------------------------|
| =:value=     | Current selected value                |
| =:options=   | List of options (strings or alist)    |
| =:on-change= | Callback with selected value          |
| =:prompt=    | Prompt text (default: "Select: ")     |
| =:key=       | Key for reconciliation                |

*** With Custom Prompt

#+begin_src elisp
(vui-select :value priority
            :options '("Low" "Medium" "High" "Critical")
            :prompt "Priority: "
            :on-change (lambda (v) (vui-set-state :priority v)))
#+end_src

*** Options as Cons Cells

For display-value pairs, use cons cells:

#+begin_src elisp
(vui-select :value country-code
            :options '(("United States" . "US")
                       ("United Kingdom" . "UK")
                       ("Germany" . "DE"))
            :on-change (lambda (code)
                         (vui-set-state :country-code code)))
;; Shows: "United States", stores: "US"
#+end_src

* Grouping Elements

** =vui-fragment= - Invisible Group

Groups multiple elements without adding any visible output:

#+begin_src elisp
(vui-fragment
 (vui-text "Line 1")
 (vui-newline)
 (vui-text "Line 2")
 (vui-newline)
 (vui-button "Action"))
#+end_src

Fragments are essential when a render function needs to return multiple elements:

#+begin_src elisp
(defcomponent multi-line ()
  :render
  (vui-fragment  ; Without this, only the last element would be returned
   (vui-text "First")
   (vui-newline)
   (vui-text "Second")))
#+end_src

*** Nested Fragments

Fragments can be nested and will be flattened:

#+begin_src elisp
(vui-fragment
 (vui-fragment
  (vui-text "A")
  (vui-text "B"))
 (vui-fragment
  (vui-text "C")
  (vui-text "D")))
;; Renders: ABCD
#+end_src

*** Nil Children Are Ignored

#+begin_src elisp
(vui-fragment
 (when show-header (vui-text "Header"))
 (vui-text "Body")
 (when show-footer (vui-text "Footer")))
;; If show-header is nil, it's simply skipped
#+end_src

* Summary Table

| Primitive      | Purpose              | Key Props                              |
|----------------+----------------------+----------------------------------------|
| =vui-text=     | Display text         | =:face=, =:key=                        |
| =vui-newline=  | Line break           | =:key=                                 |
| =vui-space=    | Whitespace           | width, =:key=                          |
| =vui-button=   | Clickable button     | =:on-click=, =:disabled=, =:max-width= |
| =vui-field=    | Text input           | =:value=, =:on-change=                 |
| =vui-checkbox= | Toggle checkbox      | =:checked=, =:on-change=               |
| =vui-select=   | Dropdown selection   | =:value=, =:options=, =:on-change=     |
| =vui-fragment= | Group without output | children                               |

* Complete Example

Here's a component using multiple primitives:

#+begin_src elisp
(defcomponent user-form ()
  :state ((name "")
          (email "")
          (newsletter nil)
          (role "user"))
  :render
  (vui-fragment
   (vui-text "User Registration" :face 'bold)
   (vui-newline)
   (vui-newline)

   ;; Name field
   (vui-text "Name: ")
   (vui-field :value name
              :size 25
              :on-change (lambda (v) (vui-set-state :name v)))
   (vui-newline)

   ;; Email field
   (vui-text "Email: ")
   (vui-field :value email
              :size 25
              :on-change (lambda (v) (vui-set-state :email v)))
   (vui-newline)

   ;; Newsletter checkbox
   (vui-checkbox :checked newsletter
                 :label "Subscribe to newsletter"
                 :on-change (lambda (v) (vui-set-state :newsletter v)))
   (vui-newline)

   ;; Role selection
   (vui-text "Role: ")
   (vui-select :value role
               :options '("user" "editor" "admin")
               :on-change (lambda (v) (vui-set-state :role v)))
   (vui-newline)
   (vui-newline)

   ;; Submit button
   (vui-button "Submit"
               :on-click (lambda ()
                           (message "Submitted: %s <%s> role=%s news=%s"
                                    name email role newsletter))
               :disabled (or (string-empty-p name)
                             (string-empty-p email)))))

(vui-mount (vui-component 'user-form) "*user-form*")
#+end_src

* Try It Yourself

#+begin_quote
*Exercise*: Create a =rating-input= component that:

1. Shows 5 buttons labeled "1" through "5"
2. Highlights the selected rating with a different face
3. Has a =:value= prop and =:on-change= callback
#+end_quote

#+begin_src elisp
(defcomponent rating-input (value on-change)
  :render
  ;; Hint: Use cl-loop and vui-hstack
  )
#+end_src

* What's Next?

- [[file:04-layout.org][Layout]] - Arrange primitives with hstack, vstack, box, and table
- [[file:02-components.org][Components]] - Creating and composing components
