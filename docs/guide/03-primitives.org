#+TITLE: Primitives
#+AUTHOR: vui.el Documentation
#+OPTIONS: toc:2 num:t

Primitives are the basic building blocks for creating UIs in vui.el. They
represent the fundamental elements that can be rendered to a buffer.

* Text Display

** =vui-text= — Display Text

The most basic primitive. Displays text content.

#+begin_src elisp
(vui-text "Hello, World!")
#+end_src

*** With Face (Styling)

#+begin_src elisp
(vui-text "Error: Something went wrong" :face 'error)
(vui-text "Success!" :face 'success)
(vui-text "Dimmed text" :face 'shadow)
#+end_src

*** With Text Properties

#+begin_src elisp
(vui-text "Important" :face '(:weight bold :foreground "red"))
#+end_src

*** With Key (for Reconciliation)

#+begin_src elisp
(vui-text "Status message" :key "status")
#+end_src

*** Plain Strings

For convenience, plain strings are automatically treated as text:

#+begin_src elisp
(vui-fragment
 "This is plain text"      ; Same as (vui-text "This is plain text")
 (vui-newline)
 "More text")
#+end_src

** =vui-newline= — Line Break

Inserts a newline character:

#+begin_src elisp
(vui-fragment
 (vui-text "Line 1")
 (vui-newline)
 (vui-text "Line 2"))
#+end_src

Output:
#+begin_example
Line 1
Line 2
#+end_example

** =vui-space= — Horizontal Space

Inserts whitespace:

#+begin_src elisp
(vui-space)      ; Default: 1 space
(vui-space 5)    ; 5 spaces
#+end_src

* Interactive Elements

** =vui-button= — Clickable Button

Creates a button that responds to user activation (=RET= or mouse click).

#+begin_src elisp
(vui-button "Click me"
            :on-click (lambda () (message "Clicked!")))
#+end_src

*** Button Properties

| Property     | Description                          |
|--------------+--------------------------------------|
| =:on-click=  | Callback when activated              |
| =:face=      | Button face/styling                  |
| =:disabled=  | When non-nil, button is inactive     |
| =:key=       | Key for reconciliation               |

*** Disabled Button

Disabled buttons render as plain text and don't respond to clicks:

#+begin_src elisp
(vui-button "Submit"
            :on-click #'do-submit
            :disabled (not form-valid))
#+end_src

*** Styled Button

#+begin_src elisp
(vui-button "Danger!"
            :on-click #'dangerous-action
            :face '(:foreground "red" :weight bold))
#+end_src

** =vui-field= — Text Input

Creates an editable text field:

#+begin_src elisp
(vui-field :value current-name
           :on-change (lambda (new-value)
                        (vui-set-state :name new-value)))
#+end_src

*** Field Properties

| Property      | Description                           |
|---------------+---------------------------------------|
| =:value=      | Current field value (string)          |
| =:on-change=  | Callback with new value when edited   |
| =:on-submit=  | Callback when RET pressed in field    |
| =:size=       | Field width in characters             |
| =:key=        | Key for reconciliation                |

*** Field with Size

#+begin_src elisp
(vui-field :value email
           :size 30
           :on-change (lambda (v) (vui-set-state :email v)))
#+end_src

*** Submit Handling

#+begin_src elisp
(vui-field :value search-term
           :on-change (lambda (v) (vui-set-state :search-term v))
           :on-submit (lambda () (do-search search-term)))
#+end_src

*** Reading Field Value

In event handlers, use =vui-field-value= to read the current field value:

#+begin_src elisp
(defcomponent search-form ()
  :state ((query ""))
  :render
  (vui-hstack
   (vui-field :key "search-input"
              :value query
              :size 20
              :on-change (lambda (v) (vui-set-state :query v)))
   (vui-button "Search"
               :on-click (lambda ()
                           (let ((value (vui-field-value "search-input")))
                             (message "Searching for: %s" value))))))
#+end_src

** =vui-checkbox= — Toggle Checkbox

Creates a checkbox that can be toggled:

#+begin_src elisp
(vui-checkbox :checked enabled
              :label "Enable feature"
              :on-change (lambda (new-value)
                           (vui-set-state :enabled new-value)))
#+end_src

*** Checkbox Properties

| Property     | Description                           |
|--------------+---------------------------------------|
| =:checked=   | Boolean, whether checked              |
| =:label=     | Optional label text after checkbox    |
| =:on-change= | Callback with new boolean value       |
| =:key=       | Key for reconciliation                |

*** Without Label

#+begin_src elisp
(vui-hstack
 (vui-checkbox :checked done
               :on-change (lambda (v) (vui-set-state :done v)))
 (vui-text task-name))
#+end_src

** =vui-select= — Dropdown Selection

Creates a selection from a list of options:

#+begin_src elisp
(vui-select current-value
            '("Option 1" "Option 2" "Option 3")
            :on-change (lambda (new-value)
                         (vui-set-state :selection new-value)))
#+end_src

*** Select Properties

| Property     | Description                           |
|--------------+---------------------------------------|
| =:on-change= | Callback with selected value          |
| =:prompt=    | Prompt text (default: "Select: ")     |
| =:key=       | Key for reconciliation                |

*** With Custom Prompt

#+begin_src elisp
(vui-select priority
            '("Low" "Medium" "High" "Critical")
            :prompt "Priority: "
            :on-change (lambda (v) (vui-set-state :priority v)))
#+end_src

*** Options as Cons Cells

For display-value pairs, use cons cells:

#+begin_src elisp
(vui-select country-code
            '(("United States" . "US")
              ("United Kingdom" . "UK")
              ("Germany" . "DE"))
            :on-change (lambda (code)
                         (vui-set-state :country-code code)))
;; Shows: "United States", stores: "US"
#+end_src

* Grouping Elements

** =vui-fragment= — Invisible Group

Groups multiple elements without adding any visible output:

#+begin_src elisp
(vui-fragment
 (vui-text "Line 1")
 (vui-newline)
 (vui-text "Line 2")
 (vui-newline)
 (vui-button "Action"))
#+end_src

Fragments are essential when a render function needs to return multiple
elements:

#+begin_src elisp
(defcomponent multi-line ()
  :render
  (vui-fragment  ; Without this, only the last element would be returned
   (vui-text "First")
   (vui-newline)
   (vui-text "Second")))
#+end_src

*** Nested Fragments

Fragments can be nested and will be flattened:

#+begin_src elisp
(vui-fragment
 (vui-fragment
  (vui-text "A")
  (vui-text "B"))
 (vui-fragment
  (vui-text "C")
  (vui-text "D")))
;; Renders: ABCD
#+end_src

*** Nil Children Are Ignored

#+begin_src elisp
(vui-fragment
 (when show-header (vui-text "Header"))
 (vui-text "Body")
 (when show-footer (vui-text "Footer")))
;; If show-header is nil, it's simply skipped
#+end_src

* Summary Table

| Primitive        | Purpose                | Key Props                    |
|------------------+------------------------+------------------------------|
| =vui-text=       | Display text           | =:face=, =:key=              |
| =vui-newline=    | Line break             | =:key=                       |
| =vui-space=      | Whitespace             | width, =:key=                |
| =vui-button=     | Clickable button       | =:on-click=, =:disabled=     |
| =vui-field=      | Text input             | =:value=, =:on-change=       |
| =vui-checkbox=   | Toggle checkbox        | =:checked=, =:on-change=     |
| =vui-select=     | Dropdown selection     | value, options, =:on-change= |
| =vui-fragment=   | Group without output   | children                     |

* Complete Example

Here's a component using multiple primitives:

#+begin_src elisp
(defcomponent user-form ()
  :state ((name "")
          (email "")
          (newsletter nil)
          (role "user"))
  :render
  (vui-fragment
   (vui-text "User Registration" :face 'bold)
   (vui-newline)
   (vui-newline)

   ;; Name field
   (vui-text "Name: ")
   (vui-field :value name
              :size 25
              :on-change (lambda (v) (vui-set-state :name v)))
   (vui-newline)

   ;; Email field
   (vui-text "Email: ")
   (vui-field :value email
              :size 25
              :on-change (lambda (v) (vui-set-state :email v)))
   (vui-newline)

   ;; Newsletter checkbox
   (vui-checkbox :checked newsletter
                 :label "Subscribe to newsletter"
                 :on-change (lambda (v) (vui-set-state :newsletter v)))
   (vui-newline)

   ;; Role selection
   (vui-text "Role: ")
   (vui-select role
               '("user" "editor" "admin")
               :on-change (lambda (v) (vui-set-state :role v)))
   (vui-newline)
   (vui-newline)

   ;; Submit button
   (vui-button "Submit"
               :on-click (lambda ()
                           (message "Submitted: %s <%s> role=%s news=%s"
                                    name email role newsletter))
               :disabled (or (string-empty-p name)
                             (string-empty-p email)))))

(vui-mount (vui-component 'user-form) "*user-form*")
#+end_src

* Try It Yourself

#+begin_quote
*Exercise*: Create a =rating-input= component that:
1. Shows 5 buttons labeled "1" through "5"
2. Highlights the selected rating with a different face
3. Has a =:value= prop and =:on-change= callback
#+end_quote

#+begin_src elisp
(defcomponent rating-input (value on-change)
  :render
  ;; Hint: Use cl-loop and vui-hstack
  )
#+end_src

* What's Next?

- [[file:04-layout.org][Layout]] — Arrange primitives with hstack, vstack, box, and table
- [[file:02-components.org][Components]] — Creating and composing components
