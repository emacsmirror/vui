#+TITLE: Context
#+AUTHOR: vui.el Documentation
#+OPTIONS: toc:2 num:t

Context provides a way to pass data through the component tree without having to pass props down manually at every level. It's useful for "global" data like themes, user authentication, or localization.

* The Problem: Prop Drilling

Consider an app where many nested components need access to the current user:

#+begin_src elisp
;; Without context: passing user through every level (prop drilling)
(defcomponent app ()
  :state ((user '(:name "Alice" :role "admin")))
  :render
  (vui-component 'layout :user user))

(defcomponent layout (user)
  :render
  (vui-component 'sidebar :user user))

(defcomponent sidebar (user)
  :render
  (vui-component 'user-info :user user))

(defcomponent user-info (user)
  :render
  (vui-text (format "Logged in as: %s" (plist-get user :name))))
#+end_src

This is tedious and makes components harder to reuse. Context solves this.

* Creating Context - =defcontext=

#+begin_src elisp
(defcontext user nil
  "The currently logged-in user.")
#+end_src

This creates:
- A context variable named =user-context=
- A provider component =user-provider=
- A hook =use-user= to consume the context

** Syntax

#+begin_src elisp
(defcontext name default-value &optional docstring)
#+end_src

* Providing Context

Wrap your component tree with the provider:

#+begin_src elisp
(defcomponent app ()
  :state ((user '(:name "Alice" :role "admin")))
  :render
  (user-provider user  ; Provide the context value
                 (vui-component 'layout)))
#+end_src

Everything inside the provider can access the context.

* Consuming Context - =use-NAME=

Use the auto-generated hook to access context:

#+begin_src elisp
(defcomponent user-info ()
  :render
  (let ((user (use-user)))  ; Get context value
    (vui-text (format "Logged in as: %s"
                      (plist-get user :name)))))
#+end_src

No more prop drilling! The component gets the user directly from context.

* Complete Example

#+begin_src elisp
;; 1. Define the context
(defcontext theme 'light
  "Current UI theme (light or dark).")

;; 2. Create components that use it
(defcomponent themed-text (content)
  :render
  (let ((theme (use-theme)))
    (vui-text content
              :face (if (eq theme 'dark)
                        '(:foreground "white" :background "black")
                      '(:foreground "black" :background "white")))))

(defcomponent theme-toggle ()
  :render
  (let ((theme (use-theme)))
    (vui-button (format "Theme: %s" theme)
                :on-click (lambda ()
                            ;; Note: This won't work! See next section
                            (message "Can't change context from here")))))

;; 3. Provide the context
(defcomponent app ()
  :state ((current-theme 'light))
  :render
  (theme-provider current-theme
                  (vui-fragment
                   (vui-component 'themed-text :content "Hello!")
                   (vui-newline)
                   (vui-button "Toggle theme"
                               :on-click (lambda ()
                                           (vui-set-state
                                            :current-theme
                                            (if (eq current-theme 'light)
                                                'dark
                                              'light)))))))
#+end_src

* Updating Context

Context values are read-only from consumers. To update context, you have two options:

** Option 1: Provide a Setter in Context

#+begin_src elisp
(defcontext user nil)

(defcomponent app ()
  :state ((user '(:name "Alice")))
  :render
  (let ((context-value (list :user user
                             :set-user (lambda (new-user)
                                         (vui-set-state :user new-user)))))
    (user-provider context-value
                   (vui-component 'user-editor))))

(defcomponent user-editor ()
  :render
  (let* ((ctx (use-user))
         (user (plist-get ctx :user))
         (set-user (plist-get ctx :set-user)))
    (vui-fragment
     (vui-text (format "Name: %s" (plist-get user :name)))
     (vui-newline)
     (vui-button "Change name"
                 :on-click (lambda ()
                             (funcall set-user '(:name "Bob")))))))
#+end_src

** Option 2: Lift State to Provider

#+begin_src elisp
;; Theme context with setter pattern
(defcontext theme-context nil)

(defcomponent theme-provider-wrapper ()
  :state ((theme 'light))
  :render
  (theme-context-provider
   (list :theme theme
         :toggle (lambda ()
                   (vui-set-state :theme
                                  (if (eq theme 'light) 'dark 'light))))
   children))

(defcomponent theme-consumer ()
  :render
  (let* ((ctx (use-theme-context))
         (theme (plist-get ctx :theme))
         (toggle (plist-get ctx :toggle)))
    (vui-button (format "Theme: %s (click to toggle)" theme)
                :on-click toggle)))
#+end_src

* Nested Providers

Providers can be nested - inner providers override outer ones:

#+begin_src elisp
(defcontext level 0)

(defcomponent nested-example ()
  :render
  (level-provider 1
                  (vui-fragment
                   (vui-component 'show-level)  ; Shows 1
                   (vui-newline)
                   (level-provider 2
                                   (vui-component 'show-level)))))  ; Shows 2

(defcomponent show-level ()
  :render
  (vui-text (format "Level: %d" (use-level))))
#+end_src

* Multiple Contexts

You can define and use multiple contexts:

#+begin_src elisp
(defcontext user nil)
(defcontext theme 'light)
(defcontext locale "en")

(defcomponent app ()
  :state ((user '(:name "Alice"))
          (theme 'dark)
          (locale "fr"))
  :render
  (user-provider user
                 (theme-provider theme
                                 (locale-provider locale
                                                  (vui-component 'main-view)))))

(defcomponent main-view ()
  :render
  (let ((user (use-user))
        (theme (use-theme))
        (locale (use-locale)))
    (vui-text (format "User: %s, Theme: %s, Locale: %s"
                      (plist-get user :name)
                      theme
                      locale))))
#+end_src

* Default Values

When no provider is found, context returns the default value:

#+begin_src elisp
(defcontext optional-data "default-value")

(defcomponent uses-optional ()
  :render
  (let ((data (use-optional-data)))
    ;; Returns "default-value" if no provider above
    (vui-text (format "Data: %s" data))))
#+end_src

* When to Use Context

** Good Use Cases

- Theme (dark/light mode)
- Current user/authentication
- Locale/internationalization
- Feature flags
- UI configuration (font size, density)

** Avoid Using Context For

- Data that changes frequently (use props or state instead)
- Data only needed by one component (just use props)
- Complex state management (consider other patterns)

* Summary

| API             | Purpose                       |
|-----------------+-------------------------------|
| =defcontext=    | Define a new context          |
| =NAME-provider= | Provide context value to tree |
| =use-NAME=      | Consume context value         |

* Try It Yourself

#+begin_quote
*Exercise*: Create a notification system using context:

1. Define a =notifications= context
2. Create a =notification-provider= that manages a list of notifications
3. Provide =add-notification= and =clear-notifications= functions
4. Create a =notification-list= component that displays notifications
5. Create an =add-notification-button= component
#+end_quote

#+begin_src elisp
(defcontext notifications nil)

(defcomponent notification-app ()
  :state ((notifications '()))
  :render
  ;; Your implementation
  )
#+end_src

* What's Next?

- [[file:07-lifecycle.org][Lifecycle]] - Component lifecycle hooks
- [[file:05-hooks.org][Hooks]] - use-effect, use-ref, use-memo
