#+TITLE: Getting Started with vui.el
#+AUTHOR: vui.el Documentation
#+OPTIONS: toc:2 num:t

* Introduction

*vui.el* is a declarative, component-based UI library for Emacs. If you've used React, Vue, or similar frameworks, you'll feel right at home. If not, don't worry - the concepts are simple:

- *Declarative*: Describe /what/ your UI should look like, not /how/ to update it
- *Component-based*: Build UIs from small, reusable pieces
- *Reactive*: When state changes, the UI updates automatically

#+begin_quote
Think of vui.el as "React for Emacs buffers" - but designed specifically for Emacs's text-based, keyboard-driven environment.
#+end_quote

* Installation

** From Source

Clone the repository and add it to your load path:

#+begin_src elisp
(add-to-list 'load-path "/path/to/vui.el")
(require 'vui)
#+end_src

** Dependencies

vui.el has no external dependencies. It only requires built-in Emacs libraries:

- =cl-lib= (structures and utilities)
- =wid-edit= (widget.el for input handling)

* Your First Component

Let's start with the simplest possible component:

#+begin_src elisp
(defcomponent hello-world ()
  :render (vui-text "Hello, World!"))
#+end_src

This defines a component named =hello-world= that renders the text "Hello, World!".

To see it in action:

#+begin_src elisp
(vui-mount (vui-component 'hello-world) "*my-first-vui*")
#+end_src

A new buffer named =*my-first-vui*= will appear with your greeting.

** Understanding the Code

Let's break down what happened:

1. =defcomponent= defines a new component type (like a template)
2. =hello-world= is the component's name
3. =()= means this component takes no props (inputs)
4. =:render= specifies what the component displays
5. =vui-text= creates a text node
6. =vui-mount= creates a live instance and renders it to a buffer

* Adding Interactivity

Static text is boring. Let's make a button:

#+begin_src elisp
(defcomponent click-counter ()
  :state ((count 0))
  :render
  (vui-fragment
   (vui-text (format "Clicked: %d times" count))
   (vui-newline)
   (vui-button "Click me!"
               :on-click (lambda ()
                           (vui-set-state :count (1+ count))))))
#+end_src

Mount it:

#+begin_src elisp
(vui-mount (vui-component 'click-counter) "*counter*")
#+end_src

Now you have a button! Press =RET= on it to increment the counter.

** What's New Here?

- =:state ((count 0))= - Defines local state with =count= starting at 0
- =vui-fragment= - Groups multiple elements without adding wrapper text
- =vui-newline= - Inserts a line break
- =vui-button= - Creates a clickable button
- =:on-click= - Callback when button is activated
- =vui-set-state= - Updates state and triggers re-render

The magic: when you call =vui-set-state=, vui.el automatically re-renders the component with the new state. You never manually update the buffer.

* Props: Passing Data to Components

Components can receive data from their parent via *props*:

#+begin_src elisp
(defcomponent greeter (name)
  :render (vui-text (format "Hello, %s!" name)))

;; Use it:
(vui-mount (vui-component 'greeter :name "Alice") "*greeter*")
;; Shows: "Hello, Alice!"
#+end_src

Props are listed in the argument list =(name)= and accessed as regular variables in the render function.

* Composing Components

The real power comes from combining components:

#+begin_src elisp
(defcomponent greeting-card (title)
  :state ((expanded nil))
  :render
  (vui-fragment
   (vui-button (if expanded "▼" "▶")
               :on-click (lambda ()
                           (vui-set-state :expanded (not expanded))))
   (vui-text (format " %s" title))
   (vui-newline)
   (when expanded
     (vui-fragment
      (vui-text "  Welcome to vui.el!")
      (vui-newline)
      (vui-text "  This is a collapsible card.")))))

(vui-mount (vui-component 'greeting-card :title "My Card") "*card*")
#+end_src

Click the arrow to expand/collapse the card.

** Key Insight

Notice how the render function is just Emacs Lisp. You can use =when=, =if=, =cl-loop=, or any other control flow. The render function runs every time state changes, and vui.el figures out what to update in the buffer.

* Input Fields

vui.el supports text input via =vui-field=:

#+begin_src elisp
(defcomponent name-form ()
  :state ((name ""))
  :render
  (vui-fragment
   (vui-text "Enter your name: ")
   (vui-field :value name
              :size 20
              :on-change (lambda (new-value)
                           (vui-set-state :name new-value)))
   (vui-newline)
   (vui-newline)
   (vui-text (if (string-empty-p name)
                 "Type something above..."
               (format "Hello, %s!" name)))))

(vui-mount (vui-component 'name-form) "*name-form*")
#+end_src

The greeting updates as you type!

* Quick Reference

| Function        | Purpose                        |
|-----------------+--------------------------------|
| =defcomponent=  | Define a new component type    |
| =vui-component= | Create a component vnode       |
| =vui-mount=     | Render component to a buffer   |
| =vui-set-state= | Update component state         |
| =vui-text=      | Render text                    |
| =vui-button=    | Render clickable button        |
| =vui-field=     | Render text input field        |
| =vui-fragment=  | Group elements without wrapper |
| =vui-newline=   | Insert line break              |

* Try It Yourself

Here's a challenge to test your understanding:

#+begin_quote
*Exercise*: Create a component called =todo-item= that:

1. Takes a =text= prop
2. Has a =done= state (initially =nil=)
3. Shows a checkbox (=[ ]= or =[X]=) as a button that toggles =done=
4. Shows the text, with =shadow= face when done
#+end_quote

Hint: Use =:face= property on =vui-text= to style text.

#+begin_src elisp
;; Your solution here:
(defcomponent todo-item (text)
  :state ((done nil))
  :render
  ;; ... fill in the rest
  )
#+end_src

See [[file:../examples/01-hello-world.el][examples/01-hello-world.el]] for the solution.

* What's Next?

Now that you understand the basics, explore:

- [[file:02-components.org][Components]] - Deep dive into defcomponent, props, and state
- [[file:03-primitives.org][Primitives]] - All the built-in UI elements
- [[file:04-layout.org][Layout]] - Arrange elements with hstack, vstack, tables
- [[file:05-hooks.org][Hooks]] - Side effects, refs, and memoization

Or jump straight to [[file:../examples/03-todo-app.el][a complete todo app example]].
