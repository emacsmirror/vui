#+TITLE: Lifecycle Hooks
#+AUTHOR: vui.el Documentation
#+OPTIONS: toc:2 num:t

Lifecycle hooks let you run code at specific points in a component's life:
when it mounts, updates, or unmounts.

* Overview

| Hook          | When It Runs                          |
|---------------+---------------------------------------|
| =:on-mount=   | After first render                    |
| =:on-update=  | After re-renders (not first)          |
| =:on-unmount= | Before component is removed           |

* Mount - =:on-mount=

Runs once after the component is first rendered:

#+begin_src elisp
(defcomponent my-component ()
  :on-mount
  (message "Component mounted!")

  :render
  (vui-text "Hello"))
#+end_src

** Use Cases

- Fetching initial data
- Setting up subscriptions
- Focusing an input field
- Logging/analytics

** Arguments

The mount hook receives =props= and =state=:

#+begin_src elisp
(defcomponent with-mount-args (name)
  :state ((count 0))
  :on-mount
  (message "Mounted with name=%s, count=%d" name count)

  :render
  (vui-text name))
#+end_src

* Update - =:on-update=

Runs after every re-render (but not the first render):

#+begin_src elisp
(defcomponent tracking-updates ()
  :state ((count 0))
  :on-update
  (message "Component updated! Count is now: %d" count)

  :render
  (vui-button (format "Count: %d" count)
              :on-click (lambda ()
                          (vui-set-state :count (1+ count)))))
#+end_src

** Arguments

The update hook receives current and previous values:

#+begin_src elisp
(defcomponent tracking-changes (value)
  :state ((internal 0))
  :on-update
  (message "Props: %s -> %s, State: %s -> %s"
           prev-props props
           prev-state state)

  :render
  (vui-text (format "%s - %d" value internal)))
#+end_src

The available variables are:
- =props= - Current props
- =state= - Current state
- =prev-props= - Previous props
- =prev-state= - Previous state

** Comparing Changes

#+begin_src elisp
(defcomponent smart-updater (data)
  :on-update
  (let ((old-data (plist-get prev-props :data))
        (new-data (plist-get props :data)))
    (unless (equal old-data new-data)
      (message "Data actually changed!")))

  :render
  (vui-text (format "Data: %s" data)))
#+end_src

* Unmount - =:on-unmount=

Runs before the component is removed from the tree:

#+begin_src elisp
(defcomponent cleanup-example ()
  :on-unmount
  (message "Cleaning up!")

  :render
  (vui-text "I'm here for now"))
#+end_src

** Use Cases

- Canceling timers
- Removing event listeners
- Saving draft data
- Cleanup of external resources

** Example: Timer Cleanup

#+begin_src elisp
(defcomponent auto-refresh ()
  :state ((data nil)
          (timer nil))

  :on-mount
  (let ((timer (run-with-timer 5 5 #'fetch-new-data)))
    (vui-set-state :timer timer))

  :on-unmount
  (when timer
    (cancel-timer timer))

  :render
  (vui-text (format "Data: %s" data)))
#+end_src

* Execution Order

When components nest, hooks run in specific orders:

** Mount Order

Children mount before parents:

#+begin_example
- Parent mounts
  - Child 1 mounts
  - Child 2 mounts
- Parent :on-mount runs
  - Child 1 :on-mount runs
  - Child 2 :on-mount runs
#+end_example

Actually, each component's =:on-mount= runs right after its own render.

** Unmount Order

Children unmount before parents (depth-first):

#+begin_example
Child 1 :on-unmount
Child 2 :on-unmount
Parent :on-unmount
#+end_example

* Lifecycle vs use-effect

Both can achieve similar goals. Here's when to use each:

| Scenario                          | Use                |
|-----------------------------------+--------------------|
| Simple setup on mount             | =:on-mount=        |
| Setup that depends on props/state | =use-effect=       |
| Simple cleanup on unmount         | =:on-unmount=      |
| Cleanup tied to specific values   | =use-effect=       |
| Compare previous/current values   | =:on-update=       |
| React to specific dep changes     | =use-effect=       |

** Lifecycle Hooks

#+begin_src elisp
;; Simpler, declarative
(defcomponent with-lifecycle ()
  :on-mount (message "mounted")
  :on-unmount (message "unmounting")
  :render ...)
#+end_src

** use-effect

#+begin_src elisp
;; More flexible, dependency-aware
(defcomponent with-effect ()
  :render
  (progn
    (use-effect ()
      (message "mounted")
      (lambda () (message "unmounting")))
    ...))
#+end_src

* Error Handling in Lifecycle

Lifecycle hooks are wrapped in error handling. If an error occurs:

1. The error is caught
2. =vui-last-error= is set with details
3. The error handler (=vui-lifecycle-error-handler=) is called
4. The component tree continues to function

See [[file:08-error-handling.org][Error Handling]] for details.

* Complete Example

#+begin_src elisp
(defcomponent document-editor (doc-id)
  :state ((content nil)
          (loading t)
          (dirty nil)
          (save-timer nil))

  :on-mount
  (progn
    ;; Fetch document
    (fetch-document doc-id
                    (lambda (data)
                      (vui-set-state :content data)
                      (vui-set-state :loading nil)))
    ;; Auto-save timer
    (vui-set-state :save-timer
                   (run-with-timer 30 30
                                   (lambda ()
                                     (when dirty
                                       (save-document doc-id content)
                                       (vui-set-state :dirty nil))))))

  :on-update
  (let ((old-doc-id (plist-get prev-props :doc-id)))
    ;; Fetch new doc if ID changed
    (unless (equal old-doc-id doc-id)
      (vui-set-state :loading t)
      (fetch-document doc-id
                      (lambda (data)
                        (vui-set-state :content data)
                        (vui-set-state :loading nil)))))

  :on-unmount
  (progn
    ;; Save unsaved changes
    (when dirty
      (save-document doc-id content))
    ;; Cancel auto-save timer
    (when save-timer
      (cancel-timer save-timer)))

  :render
  (if loading
      (vui-text "Loading...")
    (vui-fragment
     (vui-text (format "Editing: %s%s" doc-id (if dirty " *" "")))
     (vui-newline)
     (vui-field :value content
                :on-change (lambda (v)
                             (vui-set-state :content v)
                             (vui-set-state :dirty t))))))
#+end_src

* Try It Yourself

#+begin_quote
*Exercise*: Create a =stopwatch= component that:
1. Displays elapsed time in seconds
2. Starts counting on mount
3. Stops and shows final time on unmount
4. Uses =:on-update= to log each second
#+end_quote

* What's Next?

- [[file:08-error-handling.org][Error Handling]] - Error boundaries and handlers
- [[file:05-hooks.org][Hooks]] - use-effect for more complex scenarios
