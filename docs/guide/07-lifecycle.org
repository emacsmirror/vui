#+TITLE: Lifecycle Hooks
#+AUTHOR: vui.el Documentation
#+OPTIONS: toc:2 num:t

Lifecycle hooks let you run code at specific points in a component's life: when it mounts, updates, or unmounts.

* Overview

| Hook          | When It Runs                 |
|---------------+------------------------------|
| =:on-mount=   | After first render           |
| =:on-update=  | After re-renders (not first) |
| =:on-unmount= | Before component is removed  |

* Mount - =:on-mount=

Runs once after the component is first rendered:

#+begin_src elisp
(defcomponent my-component ()
  :on-mount
  (message "Component mounted!")

  :render
  (vui-text "Hello"))
#+end_src

** Use Cases

- Fetching initial data
- Setting up subscriptions
- Focusing an input field
- Logging/analytics

** Cleanup Return Value

If =:on-mount= returns a function, it will be called during unmount:

#+begin_src elisp
(defcomponent with-mount-cleanup ()
  :on-mount
  (progn
    (message "Setting up...")
    ;; Return cleanup function
    (lambda ()
      (message "Cleaning up from mount!")))

  :render
  (vui-text "Hello"))
#+end_src

This is useful when setup and cleanup are closely related.

* Update - =:on-update=

Runs after every re-render (but not the first render):

#+begin_src elisp
(defcomponent tracking-updates ()
  :state ((count 0))
  :on-update
  (message "Component updated! Count is now: %d" count)

  :render
  (vui-button (format "Count: %d" count)
              :on-click (lambda ()
                          (vui-set-state :count (1+ count)))))
#+end_src

** Arguments

The update hook receives current and previous values:

#+begin_src elisp
(defcomponent tracking-changes (value)
  :state ((internal 0))
  :on-update
  (message "Props: %s -> %s, State: %s -> %s"
           prev-props props
           prev-state state)

  :render
  (vui-text (format "%s - %d" value internal)))
#+end_src

The available variables are:
- =props= - Current props
- =state= - Current state
- =prev-props= - Previous props
- =prev-state= - Previous state

** Comparing Changes

#+begin_src elisp
(defcomponent smart-updater (data)
  :on-update
  (let ((old-data (plist-get prev-props :data))
        (new-data (plist-get props :data)))
    (unless (equal old-data new-data)
      (message "Data actually changed!")))

  :render
  (vui-text (format "Data: %s" data)))
#+end_src

* Unmount - =:on-unmount=

Runs before the component is removed from the tree:

#+begin_src elisp
(defcomponent cleanup-example ()
  :on-unmount
  (message "Cleaning up!")

  :render
  (vui-text "I'm here for now"))
#+end_src

** Use Cases

- Canceling timers
- Removing event listeners
- Saving draft data
- Cleanup of external resources

** Example: Timer Cleanup

#+begin_src elisp
(defcomponent auto-refresh ()
  :state ((data nil))

  :on-mount
  ;; Return cleanup function that cancels the timer
  (let ((timer (run-with-timer 5 5
                 (vui-with-async-context
                   (fetch-and-update-data)))))
    (lambda ()
      (cancel-timer timer)))

  :render
  (vui-text (format "Data: %s" data)))
#+end_src

* Execution Order

When components nest, hooks run in specific orders.

** Mount Order (Bottom-Up)

Children mount before parents. Given this tree:

#+begin_src elisp
(defcomponent parent ()
  :on-mount (message "Parent mounted")
  :render
  (vui-vstack
   (vui-component 'child :name "A")
   (vui-component 'child :name "B")))

(defcomponent child (name)
  :on-mount (message "Child %s mounted" name)
  :render (vui-text name))
#+end_src

The console shows:

#+begin_example
Child A mounted
Child B mounted
Parent mounted
#+end_example

This ensures a parent's =:on-mount= can safely interact with already-mounted children.

** Update Order (Bottom-Up)

Similarly, children update before parents:

#+begin_example
Child A updated
Child B updated
Parent updated
#+end_example

** Unmount Order (Bottom-Up)

Children unmount before parents:

#+begin_example
Child A unmounting
Child B unmounting
Parent unmounting
#+end_example

* Lifecycle vs use-effect

Both can achieve similar goals. Here's when to use each:

| Scenario                          | Use           |
|-----------------------------------+---------------|
| Simple setup on mount             | =:on-mount=   |
| Setup that depends on props/state | =use-effect=  |
| Simple cleanup on unmount         | =:on-unmount= |
| Cleanup tied to specific values   | =use-effect=  |
| Compare previous/current values   | =:on-update=  |
| React to specific dep changes     | =use-effect=  |

** Lifecycle Hooks

#+begin_src elisp
;; Simpler, declarative
(defcomponent with-lifecycle ()
  :on-mount (message "mounted")
  :on-unmount (message "unmounting")
  :render ...)
#+end_src

** use-effect

#+begin_src elisp
;; More flexible, dependency-aware
(defcomponent with-effect ()
  :render
  (progn
    (use-effect ()
      (message "mounted")
      (lambda () (message "unmounting")))
    ...))
#+end_src

* Async Operations in Lifecycle

When lifecycle hooks start async operations (timers, processes, fetch callbacks), you need to use =vui-with-async-context= or =vui-async-callback= to restore the component context when the callback runs.

** Timer in on-mount

#+begin_src elisp
(defcomponent polling-component ()
  :state ((data nil))

  :on-mount
  (let ((timer (run-with-timer 10 10
                 (vui-with-async-context
                   ;; Use functional update to avoid stale closure
                   (vui-set-state :data (fetch-latest-data))))))
    ;; Return cleanup
    (lambda () (cancel-timer timer)))

  :render
  (vui-text (or data "Loading...")))
#+end_src

** Fetch with Callback

#+begin_src elisp
(defcomponent data-loader (item-id)
  :state ((data nil) (loading t))

  :on-mount
  (fetch-item item-id
    (vui-async-callback (result)
      (vui-set-state :data result)
      (vui-set-state :loading nil)))

  :render
  (if loading
      (vui-text "Loading...")
    (vui-text (format "Data: %s" data))))
#+end_src

* Error Handling in Lifecycle

Lifecycle hooks are wrapped in error handling. If an error occurs:

1. The error is caught
2. =vui-last-error= is set with details
3. The error handler (=vui-lifecycle-error-handler=) is called
4. The component tree continues to function

See [[file:08-error-handling.org][Error Handling]] for details.

* Complete Example

#+begin_src elisp
(defcomponent document-editor (doc-id)
  :state ((content nil)
          (loading t)
          (dirty nil))

  :on-mount
  (progn
    ;; Fetch document - use vui-async-callback for the response
    (fetch-document doc-id
      (vui-async-callback (data)
        (vui-set-state :content data)
        (vui-set-state :loading nil)))

    ;; Auto-save timer - use vui-with-async-context
    ;; Return cleanup function to cancel timer
    (let ((save-timer
           (run-with-timer 30 30
             (vui-with-async-context
               ;; Note: 'dirty' and 'content' would be stale here
               ;; In real code, you'd use a ref or functional update
               (save-if-dirty doc-id)))))
      (lambda ()
        (cancel-timer save-timer))))

  :on-update
  (let ((old-doc-id (plist-get prev-props :doc-id)))
    ;; Fetch new doc if ID changed
    (unless (equal old-doc-id doc-id)
      (vui-set-state :loading t)
      (fetch-document doc-id
        (vui-async-callback (data)
          (vui-set-state :content data)
          (vui-set-state :loading nil)))))

  :on-unmount
  ;; Save unsaved changes synchronously before unmount
  (when dirty
    (save-document doc-id content))

  :render
  (if loading
      (vui-text "Loading...")
    (vui-fragment
     (vui-text (format "Editing: %s%s" doc-id (if dirty " *" "")))
     (vui-newline)
     (vui-field :value content
                :on-change (lambda (v)
                             (vui-set-state :content v)
                             (vui-set-state :dirty t))))))
#+end_src

* Try It Yourself

#+begin_quote
*Exercise*: Create a =stopwatch= component that:
1. Displays elapsed time in seconds
2. Starts counting on mount
3. Stops and shows final time on unmount
4. Uses =:on-update= to log each second
#+end_quote

Hint: Use =vui-with-async-context= for the timer callback and return a cleanup
function from =:on-mount=.

* What's Next?

- [[file:08-error-handling.org][Error Handling]] - Error boundaries and handlers
- [[file:05-hooks.org][Hooks]] - use-effect for more complex scenarios
